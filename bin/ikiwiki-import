#!/usr/pkg/bin/perl

use warnings;
use strict;

use IkiWiki;


package IkiWiki::Import;

sub main {
	my ($srcdir, $setupfile, $sourcename, %params) = @_;
	die "usage: $0 <srcdir> <setupfile> <sourcename> [sourceparams]\n"
		unless defined $srcdir
			&& defined $setupfile && defined $sourcename;
	die "srcdir mustn't exist" if -e $srcdir;
	die "setupfile mustn't exist" if -e $setupfile;

	my $source = IkiWiki::Import::Source->new($sourcename, %params);
	my $config = IkiWiki::Import::Config->new($source);
	for my $post (@{IkiWiki::Import::NormalizedPosts->new($source)}) {
		IkiWiki::Import::SerializedPost->new(
			IkiWiki::Import::FormattedPost->new($post),
			$srcdir,
			$config,
		);
	}

	serialize_setup($config, $setupfile);
}

sub serialize_setup {
	my ($config, $setupfile) = @_;

	my $setup = q{};
	for my $k (keys %{$config->{keep}}) {
		$setup .= "$k: " . $config->{keep}->{$k} . "\n";
	}

	open(my $out, '>', $setupfile) || die "can't open $setupfile: $!";
	print $out $setup || die "can't write $setupfile: $!";
	close($out) || die "can't close $setupfile $!";
}


package IkiWiki::Import::Config;

use Params::Validate;

sub new {
	my ($class, $source) = validate_pos(@_, 1,
		{ isa => 'IkiWiki::Import::Source' },
	);
	my $self = { get_config($source) };
	bless($self, $class);
}

sub get_config {
	my ($source) = @_;
	my %config;

	for my $k (qw(wikiname url timezone)) {
		my $method = qq{getsetup_$k};
		$config{keep}->{$k} = $source->$method();
	}

	for my $k (qw(permalink_format)) {
		my $method = qq{getsetup_$k};
		$config{use_and_forget}->{$k} = $source->$method();
	}

	return %config;
}


package IkiWiki::Import::Source;

sub new {
	my ($class, $sourcename, %params) = @_;
	my %sources = (
		textpattern	=> 'IkiWiki::Import::Source::Textpattern',
	);
	die "unknown source '$sourcename'" unless defined $sources{$sourcename};
	return $sources{$sourcename}->new(%params);
}


package IkiWiki::Import::Source::Textpattern;
use base 'IkiWiki::Import::Source';

use Params::Validate;

sub new {
	my $class = shift;
	my (%options) = validate(@_, {
		dbname		=> 1,
		host		=> { default => q{localhost} },
		user		=> 1,
		password	=> { default => q{} },
		mysql_utf8	=> { default => 0 },
	});
	eval q{
		use DBI;
		use DBD::mysql;
	};
	if ($@) {
		die "can't speak MySQL: $@";
	}
	my $self = {
		%options,
		dbh	=> DBI->connect(
			'DBI:mysql:database=' . $options{dbname}
			. ';host=' . $options{host},
			$options{user},
			$options{password},
			{
				RaiseError => 1,
				mysql_enable_utf8 => $options{mysql_utf8},
			},
		),
	};
	bless($self, $class);
}

sub DESTROY {
	my ($self) = @_;
	$self->{dbh}->disconnect();
}

sub getsetup_wikiname {
	my ($self) = @_;
	return $self->_getsetup_foo('sitename');
}

sub getsetup_url {
	my ($self) = @_;
	return $self->_getsetup_foo('siteurl');
}

sub getsetup_timezone {
	my ($self) = @_;
	return $self->_getsetup_foo('timezone_key');
}

sub getsetup_permalink_format {
	my ($self) = @_;
	my %permalink_formats = (
		year_month_day_title	=> q{%Y/%m/%d},
	);
	my $permalink_format = $self->_getsetup_foo('permlink_mode');
	die "unknown permalink format '$permalink_format'"
		unless defined $permalink_formats{$permalink_format};
	return $permalink_formats{$permalink_format};
}

sub _getsetup_foo {
	my ($self, $txp_prefs_field) = @_;

	my $sth = $self->{dbh}->prepare(
		"SELECT val FROM txp_prefs WHERE name=?",
	);
	$sth->execute($txp_prefs_field);
	my $value = $sth->fetchrow_arrayref()->[0];
	$sth->finish();

	return $value;
}

sub _normalize_post {
	my ($raw_post) = @_;
	my $normalized_post;

	my %rules = (
		id		=> $raw_post->{ID},
		visible		=> (5 == $raw_post->{Status}
					|| 4 == $raw_post->{Status}),
		title		=> $raw_post->{Title},
		author_name	=> $raw_post->{RealName},
		author_email	=> $raw_post->{email},
		creation_date	=> $raw_post->{Posted},
		modification_date => $raw_post->{LastMod},
		expiration_date	=> $raw_post->{Expires},
		url_slug	=> $raw_post->{url_title},
		tags		=> sub {
			my @tags;
			for (qw(Category1 Category2)) {
				push @tags, lc($raw_post->{$_})
					if defined $raw_post->{$_}
						&& $raw_post->{$_};
			}
			for (split(',', $raw_post->{Keywords})) {
				push @tags, lc($_);
			}
			return \@tags;
		},
		text_format	=> 'txtl',
		#text_encoding	=> undef,
		excerpt		=> $raw_post->{Excerpt},
		body		=> sub {
			my $body = $raw_post->{Body};
			$body =~ s|\r\n|\n|g;
			utf8::decode($body);
			return _expand_txp_tags(
				$body,
				article_image => {
					id => $raw_post->{'txp_image.id'},
					ext => $raw_post->{'txp_image.ext'},
					alt => $raw_post->{'txp_image.alt'},
					caption => $raw_post->{'txp_image.caption'},
					w => $raw_post->{'txp_image.w'},
					h => $raw_post->{'txp_image.h'},
				},
				image => {
					id => '18',
				},
				tru_podcast => {
					id => $raw_post->{custom_1},
					filename => $raw_post->{filename},
				},
			);
		},
	);

	for my $key (keys %rules) {
		my $rule = $rules{$key};
		if ('CODE' eq ref($rule)) {
			$normalized_post->{$key} = $rule->();
		} else {
			$normalized_post->{$key} = $rule;
		}
	}

	return $normalized_post;
}

sub _expand_txp_tags {
	my ($body, %txp_tags) = @_;

	$body = _expand_txp_article_image($body, delete $txp_tags{article_image});
	$body = _expand_txp_image($body, delete $txp_tags{image});
	$body = _expand_txp_tru_podcast($body, delete $txp_tags{tru_podcast});

	my $leftover_keys = join(', ', keys %txp_tags);
	die "unknown <txp:foo>: $leftover_keys" if $leftover_keys;

	return $body;
}

sub _expand_txp_article_image {
	my ($body, $article_image) = @_;

	return $body unless defined $article_image->{id};

	my $hardcoded_ihu = ''; # XXX optional image host url (config.php)
	my $hardcoded_img_dir = 'images';
	my $hardcoded_thumbnail = ''; # XXX if thumbnail, 't'

	# this crappy name helps find the matching Textpattern code
	my $imagesrcurl = $hardcoded_ihu.$hardcoded_img_dir.'/'.$article_image->{id}.$hardcoded_thumbnail.$article_image->{ext};
	my $img_tag = "<img src=\"http://www.schmonz.com/$imagesrcurl\" alt=\"$article_image->{alt}\" title=\"$article_image->{caption}\" width=\"$article_image->{w}\" height=\"$article_image->{h}\" />";
	# XXX because wraptag=p, and class=article-image
	my $p_wrapped = "<p><p class=\"article-image\">$img_tag</p></p>";

	$body =~ s|<txp:article_image .+? />|$p_wrapped|g;

	return $body;
}

sub _expand_txp_image {
	my ($body, $image) = @_;

	return $body unless defined $image->{id};

	# my site has exactly one reference to one non-article image:
	$body =~ s|<txp:image id="$image->{id}" />|<img src="http://www.schmonz.com/images/$image->{id}.gif" alt="[signed] Michael D. Rosenzweig" width="224" height="39" />|g;
	return $body;

	# more generally, each post body could have any number of references
	# each of those is a database lookup (modulo memoization)
	# do this after posts are otherwise normalized (careful of $dbh)
}

sub _expand_txp_tru_podcast {
	my ($body, $tru_podcast) = @_;

	return $body unless defined $tru_podcast->{id}
		&& defined $tru_podcast->{filename};

	my $download_link = "http://www.schmonz.com/file_download/$tru_podcast->{id}/$tru_podcast->{filename}";

	$body =~ s|<txp:tru_podcast_link linktext="(.+?)" />|<a href="$download_link">$1</a>|g;

	return $body;

	# find which custom field has the value "tru_podcast"
	# that's the field whose value needs to be passed in here
}

sub get_posts {
	my ($self) = @_;
	my @normalized_posts;

	my @posts;
	my $sth = $self->{dbh}->prepare(
		"SELECT * FROM textpattern"
		. " LEFT JOIN txp_users ON textpattern.AuthorID=txp_users.name"
		. " LEFT JOIN txp_image ON textpattern.Image=txp_image.id"
		. " LEFT JOIN txp_file ON textpattern.custom_1=txp_file.id"
		. " ORDER BY Posted DESC",
	);
	$sth->execute();
	while (my $raw_post = $sth->fetchrow_hashref()) {
		push @posts, _normalize_post($raw_post);
	}
	$sth->finish();

	foreach my $post (@posts) {
		push @normalized_posts, IkiWiki::Import::NormalizedPost->new(
			$post,
			undef,
		);
	}

	return @normalized_posts;
}


package IkiWiki::Import::NormalizedPosts;

use Params::Validate;

sub new {
	my ($class, $source) = validate_pos(@_, 1,
		{ isa => 'IkiWiki::Import::Source' },
	);
	my $self = [ get_posts($source) ];
	bless($self, $class);
}

sub get_posts {
	my ($source) = @_;
	return $source->get_posts();
}


package IkiWiki::Import::NormalizedPost;

use Params::Validate qw(:all);

sub new {
	my ($class, $post, $comments) = validate_pos(@_, 1,
		{ type => HASHREF },
		{ type => UNDEF },
	);
	my $self = $post;
	$post->{comments} = $comments;
	bless($self, $class);
}


package IkiWiki::Import::FormattedPost;

use Params::Validate;

sub new {
	my ($class, $normalized_post) = validate_pos(@_, 1,
		{ isa => 'IkiWiki::Import::NormalizedPost' },
	);
	my $self = { ikiformat($normalized_post) };
	$self->{normalized_post} = $normalized_post;
	bless($self, $class);
}

sub ikiformat {
	my ($normalized_post) = @_;
	my %ikiformatted;

	my $tags = join(' ', @{$normalized_post->{tags}});
	my $tagline = $tags ? "[[!tag $tags]]" : "";

	$ikiformatted{post} =<<EOT;
<!-- ikiwiki-import id: $normalized_post->{id} -->
<!-- ikiwiki-import visible: $normalized_post->{visible} -->
[[!meta title="$normalized_post->{title}"]]
<!-- ikiwiki-import author_name: $normalized_post->{author_name} -->
<!-- ikiwiki-import author_email: $normalized_post->{author_email} -->
[[!meta date="$normalized_post->{creation_date}"]]
<!-- ikiwiki-import modification_date: $normalized_post->{modification_date} -->
<!-- ikiwiki-import expiration_date: $normalized_post->{expiration_date} -->
<!-- ikiwiki-import url_slug: $normalized_post->{url_slug} -->
$tagline
<!-- ikiwiki-import text_format: $normalized_post->{text_format} -->

$normalized_post->{body}
EOT

	return %ikiformatted;
}

sub get_post {
	my ($self) = @_;
	return $self->{post};
}


package IkiWiki::Import::SerializedPost;

use Params::Validate qw(:all);

sub new {
	my ($class, $formatted_post, $srcdir, $config) = validate_pos(@_, 1,
		{ isa => 'IkiWiki::Import::FormattedPost' },
		{ type => SCALAR },
		{ isa => 'IkiWiki::Import::Config' },
	);
	my $self = { serialize($formatted_post, $srcdir, $config) };
	bless($self, $class);
}

sub serialize {
	my ($formatted_post, $srcdir, $config) = @_;
	my %serialized;

	$serialized{post} = _get_url_preserving_filename(
		$config->{keep}->{timezone},
		$config->{use_and_forget}->{permalink_format},
		$formatted_post->{normalized_post}->{creation_date},
		$formatted_post->{normalized_post}->{url_slug},
		$formatted_post->{normalized_post}->{text_format},
	);
	IkiWiki::writefile($serialized{post}, $srcdir, $formatted_post->get_post());
	utime(
		time(),
		_get_time(
			$config->{keep}->{timezone},
			$formatted_post->{normalized_post}->{modification_date},
		),
		"$srcdir/$serialized{post}",
	);

	return %serialized;
}

sub _get_time {
	my ($timezone, $date) = @_;

	eval q{
		use Date::Parse;
	};
	if ($@) {
		die "can't compute correct datetimes: $@";
	}

	return str2time($date, $timezone);
}

sub _get_url_preserving_filename {
	my ($timezone, $permalink_format, $date, $slug, $format) = @_;

	eval q{
		use POSIX qw(strftime);
	};
	if ($@) {
		die "can't compute correct datetimes: $@";
	}
	my $date_prefix = strftime(
		$permalink_format,
		gmtime(_get_time($timezone, $date)),
	);

	return qq{$date_prefix/$slug.$format};
}

sub get_post {
	my ($self) = @_;
	return $self->{post};
}


package main;

IkiWiki::Import::main(@ARGV) unless caller();

1;
